/**
 * @module hooks/useTDDWorkflow
 * @description Custom hook for TDD workflow management (red/green/refactor cycle)
 *
 * PURPOSE:
 * - Manage TDD session state with phase tracking
 * - Guide users through red (failing test) -> green (minimal pass) -> refactor cycle
 * - Generate prompts for each phase
 * - Track session history
 *
 * DEPENDENCIES:
 * - @/lib/tauri - TDD session IPC calls
 * - @/stores/projectStore - Active project for scoping sessions
 * - @/types/test-plan - TDDSession, TDDPhase, etc.
 *
 * EXPORTS:
 * - useTDDWorkflow - Hook returning TDD workflow state and actions
 *
 * PATTERNS:
 * - Call startSession() to begin a new TDD workflow
 * - Call advancePhase() when user confirms phase completion
 * - Call recordOutput() to save test output for current phase
 * - TDD phases must complete in order: red -> green -> refactor
 *
 * CLAUDE NOTES:
 * - Red phase: User writes failing test, confirms it fails
 * - Green phase: User writes minimal code, confirms tests pass
 * - Refactor phase: User cleans up code, confirms tests still pass
 * - Sessions are tracked for history and can be resumed
 * - Phase prompts are generated by the backend
 */

import { useCallback, useState } from "react";
import { useProjectStore } from "@/stores/projectStore";
import {
  createTddSession,
  updateTddSession,
  getTddSession,
  listTddSessions,
  generateSubagentConfig,
  generateHooksConfig,
} from "@/lib/tauri";
import type { TDDSession, TDDPhase, TDDPhaseConfig } from "@/types/test-plan";

interface TDDWorkflowState {
  session: TDDSession | null;
  sessions: TDDSession[];
  loading: boolean;
  error: string | null;
}

// Phase configuration for UI display
export const TDD_PHASES: TDDPhaseConfig[] = [
  {
    id: "red",
    emoji: "ðŸ”´",
    title: "Red - Write Failing Test",
    description: "Write a test that captures the expected behavior. Run it to confirm it fails.",
    expectedOutcome: "fail",
    color: "text-red-400",
  },
  {
    id: "green",
    emoji: "ðŸŸ¢",
    title: "Green - Make It Pass",
    description: "Write the minimum code needed to make the test pass. No more, no less.",
    expectedOutcome: "pass",
    color: "text-green-400",
  },
  {
    id: "refactor",
    emoji: "ðŸ”µ",
    title: "Refactor - Clean Up",
    description: "Improve code quality while keeping tests green. Run tests after each change.",
    expectedOutcome: "pass",
    color: "text-blue-400",
  },
];

export function useTDDWorkflow() {
  const activeProject = useProjectStore((s) => s.activeProject);

  const [state, setState] = useState<TDDWorkflowState>({
    session: null,
    sessions: [],
    loading: false,
    error: null,
  });

  // Load TDD sessions for the active project
  const loadSessions = useCallback(
    async (includeCompleted?: boolean) => {
      if (!activeProject) return;

      setState((s) => ({ ...s, loading: true, error: null }));
      try {
        const sessions = await listTddSessions(activeProject.id, includeCompleted);
        setState((s) => ({ ...s, sessions, loading: false }));
      } catch (err) {
        setState((s) => ({
          ...s,
          loading: false,
          error: err instanceof Error ? err.message : "Failed to load TDD sessions",
        }));
      }
    },
    [activeProject],
  );

  // Start a new TDD session
  const startSession = useCallback(
    async (featureName: string, testFilePath?: string) => {
      if (!activeProject) return null;

      setState((s) => ({ ...s, loading: true, error: null }));
      try {
        const session = await createTddSession(activeProject.id, featureName, testFilePath);
        setState((s) => ({
          ...s,
          session,
          sessions: [session, ...s.sessions],
          loading: false,
        }));
        return session;
      } catch (err) {
        setState((s) => ({
          ...s,
          loading: false,
          error: err instanceof Error ? err.message : "Failed to start TDD session",
        }));
        return null;
      }
    },
    [activeProject],
  );

  // Resume an existing session
  const resumeSession = useCallback(async (sessionId: string) => {
    setState((s) => ({ ...s, loading: true, error: null }));
    try {
      const session = await getTddSession(sessionId);
      setState((s) => ({ ...s, session, loading: false }));
      return session;
    } catch (err) {
      setState((s) => ({
        ...s,
        loading: false,
        error: err instanceof Error ? err.message : "Failed to resume TDD session",
      }));
      return null;
    }
  }, []);

  // Record test output for the current phase
  const recordOutput = useCallback(
    async (output: string) => {
      if (!state.session) return;

      try {
        const updated = await updateTddSession(state.session.id, undefined, undefined, output);
        setState((s) => ({
          ...s,
          session: updated,
          sessions: s.sessions.map((sess) => (sess.id === updated.id ? updated : sess)),
        }));
      } catch (err) {
        setState((s) => ({
          ...s,
          error: err instanceof Error ? err.message : "Failed to record output",
        }));
      }
    },
    [state.session],
  );

  // Confirm phase completion and advance to next phase
  const advancePhase = useCallback(async () => {
    if (!state.session) return;

    const currentPhase = state.session.currentPhase;
    let nextPhase: TDDPhase;

    switch (currentPhase) {
      case "red":
        nextPhase = "green";
        break;
      case "green":
        nextPhase = "refactor";
        break;
      case "refactor":
        // Mark as complete
        try {
          const updated = await updateTddSession(
            state.session.id,
            "refactor",
            "complete",
          );
          setState((s) => ({
            ...s,
            session: updated,
            sessions: s.sessions.map((sess) => (sess.id === updated.id ? updated : sess)),
          }));
        } catch (err) {
          setState((s) => ({
            ...s,
            error: err instanceof Error ? err.message : "Failed to complete session",
          }));
        }
        return;
      default:
        return;
    }

    try {
      // Mark current phase as complete and advance to next
      const updated = await updateTddSession(state.session.id, nextPhase, "active");
      setState((s) => ({
        ...s,
        session: updated,
        sessions: s.sessions.map((sess) => (sess.id === updated.id ? updated : sess)),
      }));
    } catch (err) {
      setState((s) => ({
        ...s,
        error: err instanceof Error ? err.message : "Failed to advance phase",
      }));
    }
  }, [state.session]);

  // Mark phase as failed (user can retry)
  const failPhase = useCallback(async () => {
    if (!state.session) return;

    try {
      const updated = await updateTddSession(
        state.session.id,
        undefined,
        "failed",
      );
      setState((s) => ({
        ...s,
        session: updated,
        sessions: s.sessions.map((sess) => (sess.id === updated.id ? updated : sess)),
      }));
    } catch (err) {
      setState((s) => ({
        ...s,
        error: err instanceof Error ? err.message : "Failed to mark phase as failed",
      }));
    }
  }, [state.session]);

  // Retry a failed phase
  const retryPhase = useCallback(async () => {
    if (!state.session) return;

    try {
      const updated = await updateTddSession(
        state.session.id,
        undefined,
        "active",
      );
      setState((s) => ({
        ...s,
        session: updated,
        sessions: s.sessions.map((sess) => (sess.id === updated.id ? updated : sess)),
      }));
    } catch (err) {
      setState((s) => ({
        ...s,
        error: err instanceof Error ? err.message : "Failed to retry phase",
      }));
    }
  }, [state.session]);

  // Close the current session (without completing)
  const closeSession = useCallback(() => {
    setState((s) => ({ ...s, session: null }));
  }, []);

  // Get the current phase configuration
  const getCurrentPhaseConfig = useCallback((): TDDPhaseConfig | null => {
    if (!state.session) return null;
    return TDD_PHASES.find((p) => p.id === state.session!.currentPhase) || null;
  }, [state.session]);

  // Get the prompt for the current phase
  const getCurrentPrompt = useCallback((): string | null => {
    if (!state.session) return null;

    switch (state.session.currentPhase) {
      case "red":
        return state.session.redPrompt || null;
      case "green":
        return state.session.greenPrompt || null;
      case "refactor":
        return state.session.refactorPrompt || null;
      default:
        return null;
    }
  }, [state.session]);

  // Get phase progress (1/3, 2/3, 3/3)
  const getPhaseProgress = useCallback((): { current: number; total: number } => {
    if (!state.session) return { current: 0, total: 3 };

    const phaseIndex = TDD_PHASES.findIndex((p) => p.id === state.session!.currentPhase);
    const isComplete = state.session.phaseStatus === "complete" && state.session.completedAt;

    return {
      current: isComplete ? 3 : phaseIndex + 1,
      total: 3,
    };
  }, [state.session]);

  // Generate subagent configuration
  const getSubagentConfig = useCallback(async (agentType: string): Promise<string | null> => {
    try {
      return await generateSubagentConfig(agentType);
    } catch (err) {
      setState((s) => ({
        ...s,
        error: err instanceof Error ? err.message : "Failed to generate subagent config",
      }));
      return null;
    }
  }, []);

  // Generate hooks configuration
  const getHooksConfig = useCallback(
    async (testCommand: string, filePatterns?: string[]): Promise<string | null> => {
      try {
        return await generateHooksConfig(testCommand, filePatterns);
      } catch (err) {
        setState((s) => ({
          ...s,
          error: err instanceof Error ? err.message : "Failed to generate hooks config",
        }));
        return null;
      }
    },
    [],
  );

  // Clear error
  const clearError = useCallback(() => {
    setState((s) => ({ ...s, error: null }));
  }, []);

  return {
    ...state,
    loadSessions,
    startSession,
    resumeSession,
    recordOutput,
    advancePhase,
    failPhase,
    retryPhase,
    closeSession,
    getCurrentPhaseConfig,
    getCurrentPrompt,
    getPhaseProgress,
    getSubagentConfig,
    getHooksConfig,
    clearError,
    TDD_PHASES,
  };
}
